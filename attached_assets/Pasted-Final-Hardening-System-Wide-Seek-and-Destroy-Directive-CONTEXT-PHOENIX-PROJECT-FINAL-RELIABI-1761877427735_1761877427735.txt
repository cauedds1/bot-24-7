Final Hardening & System-Wide "Seek and Destroy" Directive
CONTEXT: PHOENIX PROJECT - FINAL RELIABILITY HARDENING & FULL SYSTEM SWEEP
Hello. A critical RuntimeError: Event loop is closed has been detected. This indicates a flaw in our shutdown architecture. This directive is a final, all-encompassing mission to fix this critical bug, conduct a new full-system audit, and autonomously correct all identified issues on the spot.
The objective is to produce a truly production-grade, resilient, and error-free application. Your final output will be a report detailing the corrections made.
Part 1: The Critical Fix Mandate (Ordered Shutdown Protocol)
Your first and most critical task is to resolve the RuntimeError: Event loop is closed.
Problem: The main asyncio event loop is closing before asynchronous clients (like httpx ) can complete their own cleanup procedures, causing a race condition and a crash.
Required Action: Implement an ordered shutdown protocol.
Centralize Asynchronous Clients: Ensure the httpx.AsyncClient is initialized once at application startup and managed centrally (e.g., in context.bot_data ).
Create a post_shutdown Hook: Create a dedicated async def shutdown_resources(context) function. This function's sole responsibility is to gracefully close all shared asynchronous resources. It must await http_client.aclose( ).
Register the Hook: When building the Application in main.py, you must register your new function using the post_shutdown parameter: Application.builder().post_shutdown(shutdown_resources).build(). This is the correct, library-approved way to manage resource cleanup.
Verify Signal Handlers: Ensure our OS signal handlers (SIGINT, SIGTERM) trigger the application's own graceful shutdown mechanism (e.g., application.stop()) and do not attempt to close the loop manually.
Part 2: The "Seek and Destroy" Final Audit Mandate
Immediately after resolving the RuntimeError, you will proceed to the "seek and destroy" phase. You are to audit the entire system again and immediately fix any problem or deviation you find.
Your Mandate: Act as the lead SRE architect. Scan every file. Your goal is to leave no weakness behind.
Action Checklist (Non-Exhaustive):
Architecture & Stability: Re-verify that the telegram.error.Conflict fix is robust. Re-verify that API calls have retry logic. Re-verify that the DB pool is used everywhere. Re-verify the bounded job queue.
Data Integrity: Run a mental trace of the data flow. Is there any path where QSC could still default to 50? Are Weighted Metrics ever zero when they shouldn't be? Is the knockout_analyzer logic complete and robust?
Code Quality & Security: Eliminate all remaining TODO/FIXME comments. Standardize all logging. Ensure no exceptions are silenced (except: pass). Verify that no sensitive information (tokens, keys) is hardcoded. Create a .gitignore file if it's missing or incomplete.
Part 3: The Strategic File Health Check
As part of your audit, use this guide to focus your attention. Your final report should implicitly confirm the health of these files.
Level 1: Maximum Attention (The Core): main.py, master_analyzer.py, job_queue.py. These must be flawless.
Level 2: Important Attention (The Support Systems): api_client.py, db_manager.py, dossier_formatter.py, confidence_calculator.py. These must be robust and bug-free.
Level 3: Routine Check (The Specialists): All other specialist analyzers (corners_analyzer.py, etc.). They must be consistent and correctly integrated.
Part 4: The Final "After-Action Report"
Your final output for this entire directive is a single report summarizing all actions taken. You are not to report problems, only solutions.
FINAL HARDENING - AFTER-ACTION REPORT
✅ 1. Critical Architecture Fixes:
Ordered Shutdown Implemented: Confirm that the RuntimeError: Event loop is closed is resolved by using the post_shutdown hook to close resources in the correct order.
(Briefly confirm the status of other critical fixes like API Retry, Startup Validation, Bounded Queue, etc.)
✅ 2. "Seek and Destroy" Audit Corrections:
(Provide a bulleted list of all the additional fixes and improvements you implemented during the final audit. Be specific.)
Example Item: Refactored corners_analyzer.py to better handle cases with missing data.
Example Item: Standardized all logging output across 5 specialist analyzer files.
Example Item: Added .envto.gitignore to prevent accidental secret exposure.
✅ 3. Final File Health Assessment:
(Provide a concise summary of the overall system health.)
Example: All files in the project have been audited and corrected. The core architecture (main, master_analyzer, job_queue) is now robust and stable. All support systems are functioning as expected. The system is deemed production-ready.
✅ 4. Final Production Readiness Score:
New Architect Score: Provide a final, updated "X/10" score reflecting the system's readiness after this comprehensive hardening operation.
Final Mandate: This is the definitive command to achieve production readiness. Your goal is a 10/10 system. Leave no stone unturned. Execute.